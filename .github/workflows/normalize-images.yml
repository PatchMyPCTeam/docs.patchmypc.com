name: Normalize GitBook assets for Git it Write

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: normalize-assets-${{ github.ref }}
  cancel-in-progress: true

jobs:
  normalize:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update to latest main (rebase)
        run: |
          git fetch origin main
          git checkout main
          git rebase origin/main

      - name: Ensure _images exists (flat)
        run: mkdir -p _images

      # 1) Copy images from .gitbook/assets → _images (flat)
      - name: Copy from .gitbook/assets → _images (flat)
        shell: bash
        run: |
          set -euo pipefail
          if [ -d ".gitbook/assets" ]; then
            while IFS= read -r -d '' src; do
              cp -f "$src" "_images/$(basename "$src")"
            done < <(find .gitbook/assets -type f -print0)
          fi

      # 2) Rename files in _images to remove spaces (spaces -> '-')
      - name: Slugify filenames in _images (remove spaces)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in _images/*; do
            b="$(basename "$f")"
            nb="$(printf '%s' "$b" | sed -E 's/%20/ /g; s/[[:space:]]+/-/g; s/-+/-/g')"
            if [ "$b" != "$nb" ]; then
              tgt="_images/$nb"
              if [ -e "$tgt" ]; then
                base="${nb%.*}"; ext="${nb##*.}"; i=1
                while [ -e "_images/${base}-${i}.${ext}" ]; do i=$((i+1)); done
                tgt="_images/${base}-${i}.${ext}"
              fi
              git mv -f "$f" "$tgt" 2>/dev/null || mv -f "$f" "$tgt"
              echo "Renamed: $b -> $(basename "$tgt")"
            fi
          done

      # 3) Write the normalizer script (plain heredoc, no tab/space tricks)
      - name: Write image normalizer script
        shell: bash
        run: |
          set -euo pipefail
          cat > normalize_images.py <<'PY'
          #!/usr/bin/env python3
            import re, glob, os
            from urllib.parse import unquote
            
            IMG_EXT = r"(?:png|jpe?g|gif|webp|svg)"
            # Last token that looks like a filename with an image extension
            FILENAME_RE = re.compile(rf'([A-Za-z0-9._()\-\ ]+\.{IMG_EXT})', re.I)
          
          def extract_filename(url: str) -> str:
                                      u = unquote(url)                          # decode %xx
                                      u = u.split('?', 1)[0].split('#', 1)[0]   # drop query/fragment
                                      m = FILENAME_RE.findall(u)
                                      fn = (m[-1] if m else os.path.basename(u)).strip()
                                      # strip any quotes that may be in the filename (from %22 etc.)
                                      return fn.replace('"','').replace("'",'').replace('“','').replace('”','').replace('’','')
          
          def slug_filename(fn: str) -> str:
                                  base, ext = os.path.splitext(fn)
                                  # also strip quotes defensively here
                                  base = base.replace('"','').replace("'",'').replace('“','').replace('”','').replace('’','')
                                  base = re.sub(r'\s+', '-', base)                    # spaces -> dash
                                  base = re.sub(r'[^A-Za-z0-9_()\-.]+', '-', base)    # keep letters,digits,_,-,(),.
                                  base = re.sub(r'-{2,}', '-', base).strip('-')       # collapse --
                                  return f"{base}{ext.lower()}"
          
          def to_root_url(url: str) -> str:
                                 return "/_images/" + slug_filename(extract_filename(url))
          
          def build_md(alt: str, url: str) -> str:
                                        alt = alt or ""
                                        alt_md = alt.replace(']', r'\]')
                                        title  = alt.replace('"', r'\"')  # title = alt
                                        return f'![{alt_md}]({to_root_url(url)} "{title}")'
            
            FILES = [p for g in ("**/*.md","**/*.MD","**/*.mdx","**/*.MDX","**/*.markdown","**/*.MARKDOWN")
            for p in glob.glob(g, recursive=True)]
            
            # Remove <figure> wrappers and figcaptions (we rebuild clean Markdown)
            FIGCAPTION = re.compile(r'<figcaption\b[^>]*>.*?</figcaption>', re.I | re.S)
            FIG_WRAP   = re.compile(r'<figure\b[^>]*>(.*?)</figure>', re.I | re.S)
            
            # <img src="..."> (alt optional)
            HTML_IMG = re.compile(
            r'<img\b[^>]*\bsrc=["\']([^"\']+)["\'][^>]*?(?:\balt=["\']([^"\']*)["\'])?[^>]*>',
            re.I
            )
            
            # Markdown images — rebuild them too
            MD_IMG = re.compile(r'!\[([^\]]*)\]\(\s*<?([^)\r\n]+?)>?(?:\s+"[^"]*")?\s*\)', re.I)          
          
            changed = 0
          for path in FILES:
            with open(path, encoding="utf-8") as f:
              s = f.read()
            o = s
            
            # 1) unwrap figures / drop captions
            s = FIGCAPTION.sub('', s)
            s = FIG_WRAP.sub(lambda m: m.group(1), s)
            
            # 2) <img> → strict Markdown
            s = HTML_IMG.sub(lambda m: build_md(m.group(2) or "", m.group(1)), s)
            
            # 3) existing Markdown → strict Markdown
            s = MD_IMG.sub(lambda m: build_md(m.group(1), m.group(2)), s)
            
            # 4) strip ../ or ./ before _images just in case
            s = re.sub(r'\]\(\s*<?(?:\.\./|\.?/)+_images/', '](/_images/', s)
            
            if s != o:
              with open(path, "w", encoding="utf-8") as f:
                f.write(s)
              print(f"Fixed: {path}")
                  changed += 1
          
          print(f"Normalized {changed} file(s).")
            PY
            chmod +x normalize_images.py
          
          - name: Normalize ALL image links to ![alt](/_images/<slug> "alt")
            shell: bash
            run: |
              set -euo pipefail
              python3 normalize_images.py

      # 4) Validate: links are ![alt](/_images/<file> "title") — no spaces/% and no subfolders
      - name: Write image links validator
        shell: bash
        run: |
          set -euo pipefail
          cat > validate_images.py <<'PY'
          #!/usr/bin/env python3
          import re, glob, sys

          exts     = r"(png|jpe?g|gif|webp|svg)"
          md_img = re.compile(r'!\[[^\]]*\]\(\s*<?([^)\r\n]+)')
          html_src = re.compile(r'\bsrc=["\']([^"\']+)["\']', re.I)
          is_img   = re.compile(rf"\.({exts})(?:$|\?)", re.I)

          def bad(u:
            str) -> bool:
              if not is_img.search(u):
                return False
              if not u.startswith("/_images/"):
                return True
              rest = u[len("/_images/"):]
              if "/" in rest:
                return True            # no subfolders
              if any(p in u for p in (" ", "%20", "%28", "%29")):
                return True            # no spaces or %
              return False
    
          bads = []
          files = [p for g in ("**/*.md","**/*.MD","**/*.mdx","**/*.MDX","**/*.markdown","**/*.MARKDOWN")
          for p in glob.glob(g, recursive=True)]
          for p in files:
            with open(p, encoding="utf-8") as f:
              s = f.read()
            bads += [(p, u.strip()) for u in md_img.findall(s)   if bad(u.strip())]
            bads += [(p, u.strip()) for u in html_src.findall(s) if bad(u.strip())]
    
          if bads:
            print("Non-compliant image links:")
            for p, u in bads:
              print(f"- {p}: { u }")
              sys.exit(1)
    
          print('All image links are ![alt](/_images/<file> "title") with no spaces/% and no subfolders.')
          PY

      - name: Validate image links style (/_images/*, no spaces or %)
        shell: bash
        run: |
          set -euo pipefail
          python3 validate_images.py


      - name: Commit changes (if any)
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "Normalize images and links to ![alt](/_images/file \"alt\") — no spaces/%"
          else
            echo "No changes to commit."
          fi

      - name: Rebase on latest and push (retry with --force-with-lease)
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main --prune
          if [ "$(git rev-list --count HEAD ^origin/main)" -eq 0 ]; then
            echo "No new commits to push."
            exit 0
          fi
          for a in 1 2 3; do
            echo "Push attempt $a..."
            if git push --force-with-lease; then exit 0; fi
            git rebase origin/main
            sleep 2
          done
          echo "Giving up after 3 attempts."; exit 1
