name: Normalize GitBook assets for Git it Write

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: normalize-assets-${{ github.ref }}
  cancel-in-progress: true

jobs:
  normalize:
    if: ${{ github.actor != 'github-actions[bot]' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - name: Configure author
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Update to latest main (rebase)
        run: |
          git fetch origin main
          git checkout main
          git rebase origin/main

      - name: Ensure _images exists (flat)
        run: mkdir -p _images

      # 1) Copy images from .gitbook/assets → _images (flat)
      - name: Copy from .gitbook/assets → _images (flat)
        shell: bash
        run: |
          set -euo pipefail
          if [ -d ".gitbook/assets" ]; then
            while IFS= read -r -d '' src; do
              base="$(basename "$src")"
              cp -f "$src" "_images/$base"
            done < <(find .gitbook/assets -type f -print0)
          fi

      # 2) Rename files in _images to remove spaces (spaces -> '-')
      - name: Slugify filenames in _images (remove spaces)
        shell: bash
        run: |
          set -euo pipefail
          shopt -s nullglob
          for f in _images/*; do
            b="$(basename "$f")"
            nb="$(printf '%s' "$b" | sed -E 's/%20/ /g; s/[[:space:]]+/-/g; s/-+/-/g')"
            if [ "$b" != "$nb" ]; then
              # Avoid collisions after rename
              tgt="_images/$nb"
              if [ -e "$tgt" ]; then
                base="${nb%.*}"; ext="${nb##*.}"; i=1
                while [ -e "_images/${base}-${i}.${ext}" ]; do i=$((i+1)); done
                tgt="_images/${base}-${i}.${ext}"
              fi
              git mv -f "$f" "$tgt" 2>/dev/null || mv -f "$f" "$tgt"
              echo "Renamed: $b -> $(basename "$tgt")"
            fi
          done

      # 3) Convert <figure><img ...><figcaption>...</figcaption></figure> → ![alt](/_images/file "alt")
      - name: Convert <figure><img> blocks to Markdown images (/_images, no spaces)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re, glob, html, os

          def slug_filename(name:str)->str:
              name = name.replace('%20',' ')
              name = re.sub(r'\s+', '-', name)   # spaces -> dash
              name = re.sub(r'-{2,}', '-', name) # collapse --
              return name

          files = [p for g in ["**/*.md","**/*.MD","**/*.mdx","**/*.MDX","**/*.markdown","**/*.MARKDOWN"]
                   for p in glob.glob(g, recursive=True)]

          FIG = re.compile(r'<figure\b[^>]*>(.*?)</figure>', re.I|re.S)
          IMG = re.compile(r'<img\b[^>]*>', re.I|re.S)
          CAP = re.compile(r'<figcaption\b[^>]*>(.*?)</figcaption>', re.I|re.S)
          def attr(n,s):
              m = re.search(rf'\b{n}\s*=\s*["\']([^"\']*)["\']', s, re.I|re.S)
              return m.group(1).strip() if m else ''

          def convert(block:str)->str:
              m = IMG.search(block)
              if not m: return block
              img = m.group(0)
              raw_src = attr('src', img)
              alt = attr('alt', img)
              # title = figcaption (preferred), else ALT
              mcap = CAP.search(block)
              cap = html.unescape(re.sub(r'<[^>]+>','',mcap.group(1))).strip() if mcap else ""
              title = cap or alt

              fn = slug_filename(os.path.basename(raw_src))
              url = f"/_images/{fn}"
              alt_md = alt.replace(']', r'\]')
              title_md = title.replace('"', r'\"')  # keep curly quotes, escape only "
              return f'![{alt_md}]({url} "{title_md}")'

          for path in files:
              s = open(path, encoding="utf-8").read()
              n = FIG.sub(lambda m: convert(m.group(0)), s)
              if n != s:
                  open(path, "w", encoding="utf-8").write(n)
                  print(f"Converted figures in: {path}")
          PY
      
      

      # 4) Normalize any remaining image links to /_images/<no-spaces>, remove prefixes/subfolders, convert bare <img> too
      - name: Normalize ALL image links to ![alt](/_images/<slug> "alt") exactly
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re, glob, os
          from urllib.parse import unquote

          IMG_EXT = r"(?:png|jpe?g|gif|webp|svg)"

          def clean_filename_from_url(url: str) -> str:
              # Take the last proper filename ending with an image extension
              matches = re.findall(rf'([^/?#]+?\.{IMG_EXT})', url, flags=re.I)
              bn = matches[-1] if matches else os.path.basename(url)
              # Decode %XX (so %28 → (, %29 → ), %20 → space)
              bn = unquote(bn)
              # Split base/ext
              if "." in bn:
                  base, ext = bn.rsplit(".", 1)
              else:
                  base, ext = bn, ""
              # Spaces → dash; keep () and _
              base = re.sub(r"\s+", "-", base)
              # Remove weird chars (leave A-Z a-z 0-9 - _ ( ) )
              base = re.sub(r"[^A-Za-z0-9\-\_\(\)]", "-", base)
              # Collapse multiple dashes and trim
              base = re.sub(r"-{2,}", "-", base).strip("-")
              return f"{base}.{ext.lower()}" if ext else base

          def to_root_image_url(url: str) -> str:
              return "/_images/" + clean_filename_from_url(url)

          def build_md(alt: str, url: str) -> str:
              alt_md = alt.replace("]", r"\]")
              title  = alt.replace('"', r'\"')          # title = alt
              return f'![{alt_md}]({to_root_image_url(url)} "{title}")'

          # Patterns
          md_files = [p for g in ["**/*.md","**/*.MD","**/*.mdx","**/*.MDX","**/*.markdown","**/*.MARKDOWN"]
                      for p in glob.glob(g, recursive=True)]

          # Markdown image: ![alt](URL "optional")
          md_img = re.compile(
            r'!\[([^\]]*)\]'           # group 1: alt
            r'\('
            r'\s*<?'                   # optional <
            r'("?)([^)\r\n]+?)\1'      # group 2: optional quote char, group 3: URL
            r'>?'                      # optional >
            r'(?:\s+"[^"]*")?'         # optional "title"
            r'\s*\)',
            re.I
          )
          
          # Use group(3) = URL only (ignore any title in source)
          s = md_img.sub(lambda m: build_md(m.group(1), m.group(3)), s)

          # <img src="..."> (alt optional)
          html_img = re.compile(
              r'<img\b[^>]*\bsrc=["\']([^"\']+)["\'][^>]*?(?:\balt=["\']([^"\']*)["\'])?[^>]*>',
              re.I
          )

          # <figure>…</figure> with inner <img> and optional <figcaption>
          FIG = re.compile(r'<figure\b[^>]*>(.*?)</figure>', re.I|re.S)
          IMG = re.compile(r'<img\b[^>]*>', re.I|re.S)
          CAP = re.compile(r'<figcaption\b[^>]*>(.*?)</figcaption>', re.I|re.S)
          def attr(n,s):
              m = re.search(rf'\b{n}\s*=\s*["\']([^"\']*)["\']', s, re.I|re.S)
              return m.group(1).strip() if m else ""

          def convert_figure(block: str) -> str:
              m = IMG.search(block)
              if not m: return block
              img = m.group(0)
              src = attr("src", img)
              alt = attr("alt", img)
              # title must equal ALT (figcaption ignored for strictness)
              return build_md(alt, src)

          for path in md_files:
              s = open(path, encoding="utf-8").read()
              o = s

              # 1) Convert <figure> blocks first
              s = FIG.sub(lambda m: convert_figure(m.group(0)), s)

              # 2) Convert standalone <img> to strict markdown
              s = html_img.sub(lambda m: build_md(m.group(2) or "", m.group(1)), s)

              # 3) Normalize existing markdown images to strict format (title = alt)
              s = md_img.sub(lambda m: build_md(m.group(1), m.group(2)), s)

              # 4) Remove any lingering ../ or ./ before _images
              s = re.sub(r'\]\(\s*<?(?:\.\./|\.?/)+_images/', '](/_images/', s)

              if s != o:
                  open(path, "w", encoding="utf-8").write(s)
                  print(f"Fixed: {path}")
          PY
      
      
      

      # 5) Validate: all image links are /_images/<no-spaces> and no subfolders
      - name: Validate image links style (/_images/*, no spaces)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import re, glob, sys
          exts = r"(png|jpe?g|gif|webp|svg)"
          md_img = re.compile(
            r'!\[[^\]]*\]\('
            r'\s*<?'
            r'("?)([^)\r\n]+?)\1'   # group 2 = URL
            r'>?'
            r'(?:\s+"[^"]*")?'
            r'\s*\)',
            re.I
          )

          html_src = re.compile(r'\bsrc=["\']([^"\']+)["\']', re.I)
          is_img = re.compile(rf"\.({exts})(?:$|\?)", re.I)

          def bad(u:str)->bool:
            if not is_img.search(u): return False
            if not u.startswith("/_images/"): return True
            rest = u[len("/_images/"):]
            if "/" in rest: return True  # no subfolders
            return " " in u  # no spaces

          bads=[]
          files=[p for g in ["**/*.md","**/*.MD","**/*.mdx","**/*.MDX","**/*.markdown","**/*.MARKDOWN"]
                    for p in glob.glob(g, recursive=True)]
          for p in files:
            s = open(p, encoding="utf-8").read()
            bads += [(p, u.strip()) for u in (m.group(2) for m in md_img.finditer(s)) if bad(u.strip())]
            bads += [(p, u.strip()) for u in html_src.findall(s) if bad(u.strip())]
          if bads:
            print("Non-compliant image links:")
            for p,u in bads: print(f"- {p}: {u}")
            sys.exit(1)
          print("All image links are /_images/<file> with no spaces and no subfolders.")
          PY

      - name: Commit changes (if any)
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git add -A
            git commit -m "Normalize: convert figures and links to ![alt](/_images/file \"alt\"), no spaces [ci skip]"
          else
            echo "No changes to commit."
          fi

      - name: Rebase on latest and push (retry with --force-with-lease)
        shell: bash
        run: |
          set -euo pipefail
          git fetch origin main --prune
          if [ "$(git rev-list --count HEAD ^origin/main)" -eq 0 ]; then
            echo "No new commits to push."
            exit 0
          fi
          for a in 1 2 3; do
            echo "Push attempt $a..."
            if git push --force-with-lease; then exit 0; fi
            git rebase origin/main
            sleep 2
          done
          echo "Giving up after 3 attempts."; exit 1
